local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "☠️ Gentle Hub | Script",
   LoadingTitle = "Pets Go! 🐾",
   LoadingSubtitle = "by Aleze",
   ConfigurationSaving = {
      Enabled = true,
      FolderName = GentleHubData, -- Create a custom folder for your hub/game
      FileName = "Gentle Hub"
   },
   Discord = {
      Enabled = true,
      Invite = "FdnfATFzUz", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ABCD would be ABCD
      RememberJoins = false -- Set this to false to make them join the discord every time they load it up
   },
   KeySystem = true, -- Set this to true to use our key system
   KeySettings = {
      Title = "Key | Gentle Hub",
      Subtitle = "Key System",
      Note = "Key In Discord Server,FdnfATFzUz",
      FileName = "GentleHubKey", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = true, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"https://pastebin.com/raw/XeHsk8eC"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local MainTab = Window:CreateTab("✔️ Home", nil) -- Title, Image

Rayfield:Notify({
   Title = "You executed the script",
   Content = "Very cool gui",
   Duration = 5,
   Image = 13047715178,
   Actions = { -- Notification Buttons
      Ignore = {
         Name = "Okay!",
         Callback = function()
         print("The user tapped Okay!")
      end
   },
},
})


local MainSection = MainTab:CreateSection("Main")

local Toggle
local autoCollectEnabled = false
local childAddedConnection

Toggle = MainTab:CreateToggle({
    Name = "Auto Collect Gifts",
    CurrentValue = false,
    Flag = "Toggle3",
    Callback = function(Value)
        autoCollectEnabled = Value

        local hiddenGiftsFolder = game.Workspace:FindFirstChild("__THINGS")
        local hiddenGiftsModel = hiddenGiftsFolder and hiddenGiftsFolder:FindFirstChild("HiddenGifts")

        if not hiddenGiftsModel then
            warn("No HiddenGifts model found in workspace.__THINGS.")
            return
        end

        local player = game.Players.LocalPlayer
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:WaitForChild("Humanoid")
        local primaryPart = character.PrimaryPart or character:WaitForChild("HumanoidRootPart")

        -- Function to make the player walk to the model and collect it
        local function walkToModel(model)
            if model:IsA("Model") and model.PrimaryPart and autoCollectEnabled then
                humanoid:MoveTo(model.PrimaryPart.Position)
                print("Walking to model: " .. model.Name)

                -- Wait until player reaches the model
                local reached = false
                local connection
                connection = humanoid.MoveToFinished:Connect(function(success)
                    if success then
                        reached = true
                        connection:Disconnect()
                        model:Destroy() -- Simulating collection
                        print("Collected model: " .. model.Name)
                    end
                end)

                while not reached and (primaryPart.Position - model.PrimaryPart.Position).Magnitude > 5 and autoCollectEnabled do
                    wait(0.5) -- Check every half a second
                end
            end
        end

        -- Function to collect all models
        local function collectAllModels()
            for _, item in ipairs(hiddenGiftsModel:GetChildren()) do
                if not autoCollectEnabled then return end
                if item:IsA("Model") and item.PrimaryPart then
                    walkToModel(item)
                end
            end
        end

        if Value then
            collectAllModels()
            if not childAddedConnection then
                childAddedConnection = hiddenGiftsModel.ChildAdded:Connect(function(child)
                    if autoCollectEnabled and child:IsA("Model") then
                        wait(1) -- Give time for the model to load properly
                        walkToModel(child)
                    end
                end)
            end
        else
            if childAddedConnection then
                childAddedConnection:Disconnect()
                childAddedConnection = nil
            end
        end
    end
})

local Toggle
local autoRollEnabled = false
local rollThread

Toggle = MainTab:CreateToggle({
    Name = "Auto Roll",
    CurrentValue = false,
    Flag = "Toggle2",
    Callback = function(Value)
        autoRollEnabled = Value

        if autoRollEnabled then
            rollThread = task.spawn(function()
                local ReplicatedStorage = game:GetService("ReplicatedStorage")
                local eggsRollFunction = ReplicatedStorage:WaitForChild("Network"):WaitForChild("Eggs_Roll")

                while autoRollEnabled do
                    local result = eggsRollFunction:InvokeServer()
                    print("Response from server:", result)
                    task.wait(0) -- Prevent freezing/crashing
                end
            end)
        else
            if rollThread then
                task.cancel(rollThread) -- Stops the loop safely
                rollThread = nil
            end
        end
    end
})


local Toggle
local autoDigEnabled = false
local childAddedConnection

Toggle = MainTab:CreateToggle({
    Name = "Auto Dig",
    CurrentValue = false,
    Flag = "Toggle1",
    Callback = function(Value)
        autoDigEnabled = Value

        local folder = game.Workspace.__THINGS.Digging
        local player = game.Players.LocalPlayer

        local function teleportToPart(part)
            if part:IsA("BasePart") and autoDigEnabled then
                player.Character:SetPrimaryPartCFrame(part.CFrame)
            end
        end

        local function teleportToAllDescendants()
            for _, object in ipairs(folder:GetDescendants()) do
                if not autoDigEnabled then return end
                teleportToPart(object)
                wait(3)
            end
        end

        local function onPartAdded(part)
            wait(0.5)
            if autoDigEnabled then
                teleportToPart(part)
            end
        end

        if Value then
            teleportToAllDescendants()
            if not childAddedConnection then
                childAddedConnection = folder.ChildAdded:Connect(onPartAdded)
            end
        else
            if childAddedConnection then
                childAddedConnection:Disconnect()
                childAddedConnection = nil
            end
        end
    end
})

local Button = MainTab:CreateButton({
    Name = "Relics collect",
    Callback = function()
        -- Toggles the relic teleportation between on or off on every button press
        _G.teleportEnabled = not _G.teleportEnabled

        if _G.teleportEnabled then
            -- Ensure the teleportation only starts once to save resources
            if _G.teleportStarted == nil then
                _G.teleportStarted = true

                -- Notifies readiness
                game.StarterGui:SetCore("SendNotification", {Title = "Relic Teleport"; Text = "Teleportation Activated!"; Duration = 5;})

                -- Local player and character setup
                local player = game.Players.LocalPlayer
                local character = player.Character or player.CharacterAdded:Wait()
                local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

                local relicsFolder = workspace:FindFirstChild("__THINGS") and workspace.__THINGS:FindFirstChild("Relics")

                if not relicsFolder then
                    warn("Relics folder not found!")
                    return
                end

                -- Function to teleport to a part
                local function teleportToPart(part)
                    if part:IsA("BasePart") then
                        -- Teleport the character to the part's position
                        humanoidRootPart.CFrame = part.CFrame + Vector3.new(0, 5, 0)  -- Slight offset to avoid overlap
                    end
                end

                -- Teleport to each relic initially
                local function teleportToAllRelics()
                    for _, relic in pairs(relicsFolder:GetChildren()) do
                        if relic:IsA("Model") and relic.PrimaryPart then
                            teleportToPart(relic.PrimaryPart)  -- Teleport to the PrimaryPart of the model
                        elseif relic:IsA("BasePart") then
                            teleportToPart(relic)  -- Teleport to the BasePart itself
                        end
                        wait(1)  -- Optional delay between teleports
                    end
                end

                teleportToAllRelics()

                -- Detect new relics spawning and teleport to them
                relicsFolder.ChildAdded:Connect(function(relic)
                    wait(0.2)  -- Small delay to ensure the relic is fully loaded
                    if relic:IsA("Model") and relic.PrimaryPart then
                        teleportToPart(relic.PrimaryPart)  -- Teleport to the PrimaryPart of the model
                    elseif relic:IsA("BasePart") then
                        teleportToPart(relic)  -- Teleport to the BasePart itself
                    end
                end)
            end
        else
            -- Deactivates teleportation
            game.StarterGui:SetCore("SendNotification", {Title = "Relic Teleport"; Text = "Teleportation Deactivated!"; Duration = 5;})

            -- Reset the teleportStarted flag when disabled to allow reactivation
            _G.teleportStarted = nil
        end
    end,
})

local MiningTab = Window:CreateTab("⛏️ Mining Area", nil)
local MiningSection = MiningTab:CreateSection("Area")

local miningPadsFolder = workspace.MAP.INTERACT.MiningPads

local function teleportToPad(pad)
	local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()

	local targetCFrame

	if pad:IsA("BasePart") then
		targetCFrame = pad.CFrame * CFrame.new(0, 5, 0) -- 5 studs above
	elseif pad:IsA("Model") then
		targetCFrame = pad:GetPivot() * CFrame.new(0, 5, 0) -- 5 studs above
	end

	character:SetPrimaryPartCFrame(targetCFrame)
end

for _, pad in ipairs(miningPadsFolder:GetChildren()) do
	if pad:IsA("BasePart") or pad:IsA("Model") then
		MiningTab:CreateButton({
			Name = pad.Name,
			Callback = function()
				teleportToPad(pad)
			end
		})
	end
end

local TPTab = Window:CreateTab("🕵️ Thieving Areas", nil) -- Title, Image

-- List of platforms to teleport to
local platforms = {
    workspace.MAP.PARTS.Platforms["Wooden Stall"],
    workspace.MAP.PARTS.Platforms["Stone Stall"],
    workspace.MAP.PARTS.Platforms["Royal Stall"],
    workspace.MAP.PARTS.Platforms["Marble Stall"],
    workspace.MAP.PARTS.Platforms["Golden Stall"],
    workspace.MAP.PARTS.Platforms["Bronze Stall"],
    workspace.MAP.PARTS.Platforms["Advanced Stall"],
    workspace.MAP.PARTS.Platforms["Busted Shack"],
}

-- Function to teleport the player to a selected Platform
local function teleportToPad(pad)
    local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    if not character then
        warn("Character not found.")
        return
    end

    -- Ensure the target object exists
    if pad then
        -- If it's a Model, teleport to the Model's PrimaryPart
        if pad:IsA("Model") then
            local primaryPart = pad.PrimaryPart
            if primaryPart then
                -- If the Model has a PrimaryPart, teleport to it
                character:SetPrimaryPartCFrame(primaryPart.CFrame)
            else
                -- Fallback: If the Model does not have a PrimaryPart, teleport to the model's position
                character:SetPrimaryPartCFrame(pad:GetModelCFrame())
            end
        -- If it's a BasePart, teleport directly to it
        elseif pad:IsA("BasePart") then
            character:SetPrimaryPartCFrame(pad.CFrame)
        else
            warn("Target is not a valid BasePart or Model.")
        end
    else
        warn("Target object does not exist.")
    end
end

-- Create Dropdown for selecting a Platform
local platformOptions = {} -- Dropdown options for each platform

-- Create a list of names for the dropdown based on the Platforms
for i, platform in ipairs(platforms) do
    -- Add the name of each platform as an option
    table.insert(platformOptions, platform.Name) -- Platform names
end

-- Create the dropdown with the Platform options
local Dropdown = TPTab:CreateDropdown({
    Name = "Select Area",
    Options = platformOptions,
    CurrentOption = {platformOptions[1]}, -- Default option
    MultipleOptions = false,
    Flag = "dropdownPlatform",
    Callback = function(selectedOption)
        -- Ensure the selected option is a string (access the first element of the table)
        local selectedPlatformName = selectedOption[1]  -- Access the first element if it's a table
        
        -- Debugging: print the selected option to make sure it's correct
        print("Selected Option: " .. selectedPlatformName)
        
        -- Find the selected platform by name
        local selectedPlatform
        for _, platform in ipairs(platforms) do
            if platform.Name == selectedPlatformName then
                selectedPlatform = platform
                break
            end
        end

        if selectedPlatform then
            teleportToPad(selectedPlatform) -- Teleport to the selected Platform
        else
            warn("Selected Platform does not exist.")
        end
    end,
})

local FishingTab = Window:CreateTab("🐟 Fishing", nil) -- Title, Image
local FishingSection = FishingTab:CreateSection("Area")

-- Function to find all objects in workspace.MAP.INTERACT.FishingPads excluding specific ones
local function findFishingPads()
    local fishingPads = {}
    local fishingPadsFolder = workspace.MAP.INTERACT.FishingPads

    -- Iterate through all children in FishingPads folder
    for _, child in ipairs(fishingPadsFolder:GetChildren()) do
        -- Exclude "Model" and "DebugPart"
        if child:IsA("BasePart") or child:IsA("Model") then
            if child.Name ~= "Model" and child.Name ~= "DebugPart" then
                table.insert(fishingPads, child)
            end
        end
    end
    return fishingPads
end

-- Function to teleport the player to a selected Fishing Pad
local function teleportToPad(pad)
    local character = game.Players.LocalPlayer.Character or game.Players.LocalPlayer.CharacterAdded:Wait()
    if not character then
        warn("Character not found.")
        return
    end

    -- Ensure the target object exists
    if pad then
        -- If it's a Model, teleport to the Model's PrimaryPart
        if pad:IsA("Model") then
            local primaryPart = pad.PrimaryPart
            if primaryPart then
                character:SetPrimaryPartCFrame(primaryPart.CFrame)
            else
                -- Fallback: If the Model does not have a PrimaryPart, teleport to the model's position
                character:SetPrimaryPartCFrame(pad:GetModelCFrame())
            end
        -- If it's a BasePart, teleport directly to it
        elseif pad:IsA("BasePart") then
            character:SetPrimaryPartCFrame(pad.CFrame)
        else
            warn("Target is not a valid BasePart or Model.")
        end
    else
        warn("Target object does not exist.")
    end
end

-- Get all fishing pads excluding "Model" and "DebugPart"
local fishingPads = findFishingPads()

-- Create options for the dropdown based on the names of the fishing pads
local fishingPadOptions = {}

for _, pad in ipairs(fishingPads) do
    table.insert(fishingPadOptions, pad.Name) -- Add the name of each pad to the options
end

-- If no pads are found, show a warning
if #fishingPadOptions == 0 then
    warn("No fishing pads found in workspace.MAP.INTERACT.FishingPads.")
end

-- Create the dropdown with the fishing pad options
local Dropdown = FishingTab:CreateDropdown({
    Name = "Select Fishing Area",
    Options = fishingPadOptions,
    CurrentOption = {fishingPadOptions[1]}, -- Default option
    MultipleOptions = false,
    Flag = "dropdownFishingPad",
    Callback = function(selectedOption)
        local selectedPadName = selectedOption[1]  -- Get the selected pad's name

        -- Find the corresponding fishing pad based on the selected name
        local selectedFishingPad
        for _, pad in ipairs(fishingPads) do
            if pad.Name == selectedPadName then
                selectedFishingPad = pad
                break
            end
        end

        if selectedFishingPad then
            teleportToPad(selectedFishingPad) -- Teleport to the selected pad
        else
            warn("Selected Fishing Pad does not exist.")
        end
    end,
})

local MiscTab = Window:CreateTab("🎲 Misc", nil) -- Title, Image
local MiscSection = MiscTab:CreateSection("Misc")

local Button = MiscTab:CreateButton({
   Name = "Infinite Jump Toggle",
   Callback = function()
       --Toggles the infinite jump between on or off on every script run
_G.infinjump = not _G.infinjump

if _G.infinJumpStarted == nil then
	--Ensures this only runs once to save resources
	_G.infinJumpStarted = true
	
	--Notifies readiness
	game.StarterGui:SetCore("SendNotification", {Title="Youtube Hub"; Text="Infinite Jump Activated!"; Duration=5;})

	--The actual infinite jump
	local plr = game:GetService('Players').LocalPlayer
	local m = plr:GetMouse()
	m.KeyDown:connect(function(k)
		if _G.infinjump then
			if k:byte() == 32 then
			humanoid = game:GetService'Players'.LocalPlayer.Character:FindFirstChildOfClass('Humanoid')
			humanoid:ChangeState('Jumping')
			wait()
			humanoid:ChangeState('Seated')
			end
		end
	end)
end
   end,
})

local Slider = MiscTab:CreateSlider({
   Name = "WalkSpeed Slider",
   Range = {1, 350},
   Increment = 1,
   Suffix = "Speed",
   CurrentValue = 16,
   Flag = "sliderws", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (Value)
   end,
})


local Slider = MiscTab:CreateSlider({
   Name = "JumpPower Slider",
   Range = {1, 350},
   Increment = 1,
   Suffix = "Speed",
   CurrentValue = 16,
   Flag = "sliderjp", -- A flag is the identifier for the configuration file, make sure every element has a different flag if you're using configuration saving to ensure no overlaps
   Callback = function(Value)
        game.Players.LocalPlayer.Character.Humanoid.JumpPower = (Value)
   end,
})


local Input = MiscTab:CreateInput({
   Name = "Walkspeed",
   PlaceholderText = "1-500",
   RemoveTextAfterFocusLost = true,
   Callback = function(Text)
        game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = (Text)
   end,
})
